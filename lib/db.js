/**
 * Common DB functionality across different microservices.
 * @module
 */
import async from 'async'
import lodash from 'lodash'
import lodashFp from 'lodash/fp'

function _load (id, senecaQuery, next) {
  senecaQuery.load$(id, (err, data) => {
    if (err) return next(err)
    if (!data) return next(new Error('#notFound'))

    next(null, data.data$())
  })
}

function _getFieldValue (object, field) {
  let fieldKey
  let fieldValue

  // If field name has a period use lodash
  // for dot notation access
  if (field.indexOf('.') > 0) {
    let keyRaw = field.split(/[\s.]+/)

    fieldKey = keyRaw[keyRaw.length - 1]
    fieldValue = lodash.chain(object)
      .at(field)
      .head()
      .value()
  } else {
    fieldKey = field
    fieldValue = object[field]
  }

  return {fieldKey, fieldValue}
}
/**
 *
 * @param {Obecjt} element Element to be stored in MongoDB.
 * @param {String} collection Collection where the element will be stored.
 * @returns {Promise}
 * @fulfil {Object} { dataRaw, data }.
 * @reject {Error} Error generated by Seneca Entity.
 */
export function save (element, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    const query = Object.assign(seneca.make$(collection), element)

    query.save$((err, dataRaw) => {
      if (err) return reject(err)

      const data = dataRaw.data$()
      resolve({dataRaw, data})
    })
  })
}
/**
 *
 * @param {Object} where Query to be executed.
 * @param {String} collection Collection to be used.
 * @returns {Promise}
 * @fulfil {Object} { dataRaw, data }.
 * @reject {Error} Error generated by Seneca Entity.
 */
export function find (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.list$(where, (err, ret) => {
      if (err) return reject(err)

      const data = ret ? ret.map(e => e.data$()) : []
      const dataRaw = ret || []

      resolve({dataRaw, data})
    })
  })
}
/**
 *
 * @param {Object} where Query to be executed.
 * @param {String} collection Collection to be used.
 * @returns {Promise}
 * @fulfil {Object} { dataRaw, data }.
 * @reject {Error} Error generated by Seneca Entity.
 */
export function findOne (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.load$(where, (err, ret) => {
      if (err) return reject(err)

      const data = ret ? ret.data$() : undefined
      const dataRaw = ret || undefined

      resolve({dataRaw, data})
    })
  })
}
/**
 *.
 * @param {Object} where Query to be executed
 * @param {String} collection Collection to be used.
 * @returns {Promise}
 * @fulfil {Object} { dataRaw, data }.
 * @reject {Error} Error generated by Seneca Entity.
 */
export function findOr (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    const conditionsTasks = where.or$.map((cond) => {
      function runQuery (next) {
        query.list$(cond, next)
      }

      return runQuery
    })

    async.series(conditionsTasks, (err, values) => {
      if (err) return reject(err)
      // Bundle all together the raw and object data
      // in order to extract them later.
      const listResult = lodash.reduce(values, (acc, v) => {
        const objs = v[0].map(e => Object.assign({}, {d: e.data$()}, {r: e}))
        return acc.concat(objs)
      }, [])

      // Merge the list by the id
      const listMerged = lodash.uniqBy(listResult, 'd.id')

      // Extract the raw and object data
      const listDataRaw = listMerged.map(r => r.r)
      const listData = listMerged.map(r => r.d)

      let dataRaw = listDataRaw || {}
      let data = listData || {}

      if (where.skip$) {
        dataRaw.splice(0, where.skip$)
        data.splice(0, where.skip$)
      }

      if (where.limit$) {
        dataRaw = dataRaw.slice(0, where.limit$)
        data = data.slice(0, where.limit$)
      }

      if (where.sort$) {
        data.sort(_sort(where.sort$))
      }
      resolve({dataRaw, data})
    })
  })
}

function _sort (condition) {
  return (a, b) => {
    let order = 0

    const keys = Object.keys(condition)

    for (let k of keys) {
      if (typeof a[k] === 'string') {
        order = a[k].localeCompare(b[k]) * condition[k]
      } else {
        order = a[k] * condition[k] - b[k] * condition[k]
      }

      if (order !== 0) break
    }

    return order
  }
}
/**
 *
 * @param {Object} dataRaw Seneca Entity
 * @param {Object} bundle
 * @param {} fields Field to be modified
 * @returns {Promise}
 * @fulfil {Object} Updated Object
 * @reject {Error} The error `name` property will be one of the following:
 */
export function update (dataRaw, bundle, fields) {
  return new Promise((resolve, reject) => {
    const originalDoc = dataRaw.data$()

    const updatedDoc = lodash.reduce(fields, (acc, f) => {
      const fieldToUpdate = lodashFp.set(f, lodash.get(bundle, f), acc)

      const merged = lodash.mergeWith(originalDoc, fieldToUpdate, (origValue, newValue) => {
        if (f.indexOf('.') > 0) {
          return Object.assign({}, origValue, newValue)
        }

        if (lodash.isArray(origValue) || lodash.isPlainObject(origValue)) {
          return newValue
        }
      })

      return merged
    }, {})

    findOne.call(this, {id: originalDoc.id}, originalDoc.entity$.name)
      .then(({dataRaw}) => {
        dataRaw.data$(updatedDoc)
          .save$((err, dataRaw) => {
            if (err) return reject(err)

            const data = dataRaw.data$()
            resolve({dataRaw, data})
          })
      })
      .catch(reject)
  })
}
/**
 *
 * @param {Object} where Query to be executed.
 * @param {String} opFields Field to be modified.
 * @param {String} collection Collection that will be updated.
 * @returns {Promise}
 * @fulfil {Number} Elements updated.
 * @reject {Error} Error generated by Seneca Entity.
 */
export function updateNative (where, opFields, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.native$((err, db) => {
      if (err) return reject(err)

      db.collection(collection)
        .findAndModify(where, [['_id', 'asc']], opFields, {new: true}, (err, result) => {
          if (err) return reject(err)
          resolve(result.value)
        })
    })
  })
}
/**
 *
 * @param {Object} where Query to be executed.
 * @param {String} collection Collection to be used.
 * @returns {Promise}
 * @fulfil {Object} Confirmation.
 * @reject {Error} Error generated by Seneca Entity.
 */
export function removeNative (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.native$((err, db) => {
      if (err) return reject(err)

      db.collection(collection)
        .remove(where, (err, result) => {
          if (err) return reject(err)
          resolve(result.result)
        })
    })
  })
}
/**
 *
 * @param {Object} where Query to be executed.
 * @param {String} collection Collection to be used.
 * @returns {Promise}
 * @fulfil {Number} 1 to confirm.
 * @reject {Error} Error
 */
export function remove (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.remove$(where, (err, data) => {
      if (err) return reject(err)
      if (!data) return reject(err)

      // It can only remove when value at a time.
      // So if it wasn't errors it means it deleted one element.
      resolve(1)
    })
  })
}
/**
 *
 * @param {Object} object Objecto op pupulate
 * @param {String} keyString Key field
 * @param {} select
 * @param {Object} collection Collection of the 'object' param
 * @returns {Promise}
 * @fulfil {Object} The data you wanted.
 * @reject {Error} The error `name` property will be one of the following:
 */
export function populate (object, keyString, select, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    // Lodash 'at' function always returns an array.
    // That's why head is invoked, it gets the first
    // element of the array, in fact, the only one.
    const subtree = lodash.chain(object)
      .at(keyString)
      .head()
      .value()

    async.map(subtree, (id, next) => {
      return _load(id, query, next)
    }, (err, values) => {
      if (err) return reject(err)
      const validValues = values.filter((v) => v !== undefined)

      let toMerge = validValues

      if (select.length > 0) {
        toMerge = lodash.reduce(validValues, (result, v) => {
          let elements = lodash.reduce(select, (acc, s) => {
            let {fieldKey, fieldValue} = _getFieldValue(v, s)
            return lodashFp.set(fieldKey, fieldValue, acc)
          }, {})

          return result.concat(elements)
        }, [])
      }

      resolve(lodashFp.set(keyString, toMerge, object))
    }
    )
  })
}
/**
 *
 * @returns {string} Generate a mongoObjectId.
 */
export function mongoObjectId () {
  var timestamp = (new Date().getTime() / 1000 | 0).toString(16)
  return timestamp + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, () => (Math.random() * 16 | 0).toString(16))
      .toLowerCase()
}
