{"version":3,"sources":["../lib/db.js"],"names":["save","find","findOne","findOr","update","updateNative","removeNative","remove","populate","mongoObjectId","_load","id","senecaQuery","next","load$","err","data","Error","data$","_getFieldValue","object","field","fieldKey","fieldValue","indexOf","keyRaw","split","length","chain","at","head","value","element","collection","seneca","Promise","resolve","reject","query","Object","assign","make$","save$","dataRaw","where","list$","ret","map","e","undefined","conditionsTasks","or$","cond","runQuery","series","values","listResult","reduce","acc","v","objs","d","r","concat","listMerged","uniqBy","listDataRaw","listData","skip$","splice","limit$","slice","sort$","sort","_sort","condition","a","b","order","keys","k","localeCompare","bundle","fields","originalDoc","updatedDoc","f","fieldToUpdate","set","get","merged","mergeWith","origValue","newValue","isArray","isPlainObject","call","entity$","name","then","catch","opFields","native$","db","findAndModify","new","result","remove$","keyString","select","subtree","validValues","filter","toMerge","elements","s","timestamp","Date","getTime","toString","replace","Math","random","toLowerCase"],"mappings":"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","file":"db.js","sourcesContent":["/**\n * Common DB functionality across different microservices.\n * @module\n */\nimport async from 'async'\nimport lodash from 'lodash'\nimport lodashFp from 'lodash/fp'\n\nfunction _load (id, senecaQuery, next) {\n  senecaQuery.load$(id, (err, data) => {\n    if (err) return next(err)\n    if (!data) return next(new Error('#notFound'))\n\n    next(null, data.data$())\n  })\n}\n\nfunction _getFieldValue (object, field) {\n  let fieldKey\n  let fieldValue\n\n  // If field name has a period use lodash\n  // for dot notation access\n  if (field.indexOf('.') > 0) {\n    let keyRaw = field.split(/[\\s.]+/)\n\n    fieldKey = keyRaw[keyRaw.length - 1]\n    fieldValue = lodash.chain(object)\n      .at(field)\n      .head()\n      .value()\n  } else {\n    fieldKey = field\n    fieldValue = object[field]\n  }\n\n  return {fieldKey, fieldValue}\n}\n/**\n *\n * @param {Obecjt} element Element to be stored in MongoDB.\n * @param {String} collection Collection where the element will be stored.\n * @returns {Promise}\n * @fulfil {Object} { dataRaw, data }.\n * @reject {Error} Error generated by Seneca Entity.\n */\nexport function save (element, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    const query = Object.assign(seneca.make$(collection), element)\n\n    query.save$((err, dataRaw) => {\n      if (err) return reject(err)\n\n      const data = dataRaw.data$()\n      resolve({dataRaw, data})\n    })\n  })\n}\n/**\n *\n * @param {Object} where Query to be executed.\n * @param {String} collection Collection to be used.\n * @returns {Promise}\n * @fulfil {Object} { dataRaw, data }.\n * @reject {Error} Error generated by Seneca Entity.\n */\nexport function find (where, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    query.list$(where, (err, ret) => {\n      if (err) return reject(err)\n\n      const data = ret ? ret.map(e => e.data$()) : []\n      const dataRaw = ret || []\n\n      resolve({dataRaw, data})\n    })\n  })\n}\n/**\n *\n * @param {Object} where Query to be executed.\n * @param {String} collection Collection to be used.\n * @returns {Promise}\n * @fulfil {Object} { dataRaw, data }.\n * @reject {Error} Error generated by Seneca Entity.\n */\nexport function findOne (where, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    query.load$(where, (err, ret) => {\n      if (err) return reject(err)\n\n      const data = ret ? ret.data$() : undefined\n      const dataRaw = ret || undefined\n\n      resolve({dataRaw, data})\n    })\n  })\n}\n/**\n *.\n * @param {Object} where Query to be executed\n * @param {String} collection Collection to be used.\n * @returns {Promise}\n * @fulfil {Object} { dataRaw, data }.\n * @reject {Error} Error generated by Seneca Entity.\n */\nexport function findOr (where, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    const conditionsTasks = where.or$.map((cond) => {\n      function runQuery (next) {\n        query.list$(cond, next)\n      }\n\n      return runQuery\n    })\n\n    async.series(conditionsTasks, (err, values) => {\n      if (err) return reject(err)\n      // Bundle all together the raw and object data\n      // in order to extract them later.\n      const listResult = lodash.reduce(values, (acc, v) => {\n        const objs = v[0].map(e => Object.assign({}, {d: e.data$()}, {r: e}))\n        return acc.concat(objs)\n      }, [])\n\n      // Merge the list by the id\n      const listMerged = lodash.uniqBy(listResult, 'd.id')\n\n      // Extract the raw and object data\n      const listDataRaw = listMerged.map(r => r.r)\n      const listData = listMerged.map(r => r.d)\n\n      let dataRaw = listDataRaw || {}\n      let data = listData || {}\n\n      if (where.skip$) {\n        dataRaw.splice(0, where.skip$)\n        data.splice(0, where.skip$)\n      }\n\n      if (where.limit$) {\n        dataRaw = dataRaw.slice(0, where.limit$)\n        data = data.slice(0, where.limit$)\n      }\n\n      if (where.sort$) {\n        data.sort(_sort(where.sort$))\n      }\n      resolve({dataRaw, data})\n    })\n  })\n}\n\nfunction _sort (condition) {\n  return (a, b) => {\n    let order = 0\n\n    const keys = Object.keys(condition)\n\n    for (let k of keys) {\n      if (typeof a[k] === 'string') {\n        order = a[k].localeCompare(b[k]) * condition[k]\n      } else {\n        order = a[k] * condition[k] - b[k] * condition[k]\n      }\n\n      if (order !== 0) break\n    }\n\n    return order\n  }\n}\n/**\n *\n * @param {Object} dataRaw Seneca Entity\n * @param {Object} bundle\n * @param {} fields Field to be modified\n * @returns {Promise}\n * @fulfil {Object} Updated Object\n * @reject {Error} The error `name` property will be one of the following:\n */\nexport function update (dataRaw, bundle, fields) {\n  return new Promise((resolve, reject) => {\n    const originalDoc = dataRaw.data$()\n\n    const updatedDoc = lodash.reduce(fields, (acc, f) => {\n      const fieldToUpdate = lodashFp.set(f, lodash.get(bundle, f), acc)\n\n      const merged = lodash.mergeWith(originalDoc, fieldToUpdate, (origValue, newValue) => {\n        if (f.indexOf('.') > 0) {\n          return Object.assign({}, origValue, newValue)\n        }\n\n        if (lodash.isArray(origValue) || lodash.isPlainObject(origValue)) {\n          return newValue\n        }\n      })\n\n      return merged\n    }, {})\n\n    findOne.call(this, {id: originalDoc.id}, originalDoc.entity$.name)\n      .then(({dataRaw}) => {\n        dataRaw.data$(updatedDoc)\n          .save$((err, dataRaw) => {\n            if (err) return reject(err)\n\n            const data = dataRaw.data$()\n            resolve({dataRaw, data})\n          })\n      })\n      .catch(reject)\n  })\n}\n/**\n *\n * @param {Object} where Query to be executed.\n * @param {String} opFields Field to be modified.\n * @param {String} collection Collection that will be updated.\n * @returns {Promise}\n * @fulfil {Number} Elements updated.\n * @reject {Error} Error generated by Seneca Entity.\n */\nexport function updateNative (where, opFields, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    query.native$((err, db) => {\n      if (err) return reject(err)\n\n      db.collection(collection)\n        .findAndModify(where, [['_id', 'asc']], opFields, {new: true}, (err, result) => {\n          if (err) return reject(err)\n          resolve(result.value)\n        })\n    })\n  })\n}\n/**\n *\n * @param {Object} where Query to be executed.\n * @param {String} collection Collection to be used.\n * @returns {Promise}\n * @fulfil {Object} Confirmation.\n * @reject {Error} Error generated by Seneca Entity.\n */\nexport function removeNative (where, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    query.native$((err, db) => {\n      if (err) return reject(err)\n\n      db.collection(collection)\n        .remove(where, (err, result) => {\n          if (err) return reject(err)\n          resolve(result.result)\n        })\n    })\n  })\n}\n/**\n *\n * @param {Object} where Query to be executed.\n * @param {String} collection Collection to be used.\n * @returns {Promise}\n * @fulfil {Number} 1 to confirm.\n * @reject {Error} Error\n */\nexport function remove (where, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    query.remove$(where, (err, data) => {\n      if (err) return reject(err)\n      if (!data) return reject(err)\n\n      // It can only remove when value at a time.\n      // So if it wasn't errors it means it deleted one element.\n      resolve(1)\n    })\n  })\n}\n/**\n *\n * @param {Object} object Objecto op pupulate\n * @param {String} keyString Key field\n * @param {} select\n * @param {Object} collection Collection of the 'object' param\n * @returns {Promise}\n * @fulfil {Object} The data you wanted.\n * @reject {Error} The error `name` property will be one of the following:\n */\nexport function populate (object, keyString, select, collection) {\n  let seneca = this\n\n  return new Promise((resolve, reject) => {\n    let query = seneca.make$(collection)\n\n    // Lodash 'at' function always returns an array.\n    // That's why head is invoked, it gets the first\n    // element of the array, in fact, the only one.\n    const subtree = lodash.chain(object)\n      .at(keyString)\n      .head()\n      .value()\n\n    async.map(subtree, (id, next) => {\n      return _load(id, query, next)\n    }, (err, values) => {\n      if (err) return reject(err)\n      const validValues = values.filter((v) => v !== undefined)\n\n      let toMerge = validValues\n\n      if (select.length > 0) {\n        toMerge = lodash.reduce(validValues, (result, v) => {\n          let elements = lodash.reduce(select, (acc, s) => {\n            let {fieldKey, fieldValue} = _getFieldValue(v, s)\n            return lodashFp.set(fieldKey, fieldValue, acc)\n          }, {})\n\n          return result.concat(elements)\n        }, [])\n      }\n\n      resolve(lodashFp.set(keyString, toMerge, object))\n    }\n    )\n  })\n}\n/**\n *\n * @returns {string} Generate a mongoObjectId.\n */\nexport function mongoObjectId () {\n  var timestamp = (new Date().getTime() / 1000 | 0).toString(16)\n  return timestamp + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, () => (Math.random() * 16 | 0).toString(16))\n      .toLowerCase()\n}\n"]}