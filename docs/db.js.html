<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: db.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: db.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module
 */
import async from 'async'
import lodash from 'lodash'
import lodashFp from 'lodash/fp'

function _load (id, senecaQuery, next) {
  senecaQuery.load$(id, (err, data) => {
    if (err) return next(err)
    if (!data) return next(new Error('#notFound'))

    next(null, data.data$())
  })
}

function _getFieldValue (object, field) {
  let fieldKey
  let fieldValue

  // If field name has a period use lodash
  // for dot notation access
  if (field.indexOf('.') > 0) {
    let keyRaw = field.split(/[\s.]+/)

    fieldKey = keyRaw[keyRaw.length - 1]
    fieldValue = lodash.chain(object)
                       .at(field)
                       .head()
                       .value()
  } else {
    fieldKey = field
    fieldValue = object[field]
  }

  return {fieldKey, fieldValue}
}
/**
 *
 * @param {Obecjt} element - Element to be stored in MongoDB
 * @param {String} collection - Collection where the element will be stored
 * @returns {Promise}
 */
export function savePromisified (element, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    const query = Object.assign(seneca.make$(collection), element)

    query.save$((err, dataRaw) => {
      if (err) return reject(err)

      const data = dataRaw.data$()
      resolve({dataRaw, data})
    })
  })
}
/**
 *
 * @param {Object} where - Query to be executed
 * @param {String} collection - Collection to be used
 * @returns {Promise} { dataRaw, data }
 */
export function findPromisified (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.list$(where, (err, ret) => {
      if (err) return reject(err)

      const data = ret ? ret.map(e => e.data$()) : []
      const dataRaw = ret || []

      resolve({dataRaw, data})
    })
  })
}
/**
 *
 * @param {Object} where - Query to be executed
 * @param {String} collection - Collection to be used
 * @returns {Promise} { dataRaw, data }
 */
export function findOnePromisified (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.load$(where, (err, ret) => {
      if (err) return reject(err)

      const data = ret ? ret.data$() : undefined
      const dataRaw = ret || undefined

      resolve({dataRaw, data})
    })
  })
}
/**
 *
 * @param {Object} where - Query to be executed
 * @param {String} collection - Collection to be used
 * @returns {Promise} { dataRaw, data }
 */
export function findOrPromisified (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    const conditionsTasks = where.or$.map((cond) => {
      function runQuery (next) {
        query.list$(cond, next)
      }

      return runQuery
    })

    async.series(conditionsTasks, (err, values) => {
      if (err) return reject(err)
      // Bundle all together the raw and object data
      // in order to extract them later.
      const listResult = lodash.reduce(values, (acc, v) => {
        const objs = v.map(e => Object.assign({}, {d: e.data$()}, {r: e}))
        return acc.concat(objs)
      }, [])

      // Merge the list by the id
      const listMerged = lodash.uniqBy(listResult, 'd.id')

      // Extract the raw and object data
      const listDataRaw = listMerged.map(r => r.r)
      const listData = listMerged.map(r => r.d)

      let dataRaw = listDataRaw || {}
      let data = listData || {}

      if (where.skip$) {
        dataRaw.splice(0, where.skip$)
        data.splice(0, where.skip$)
      }

      if (where.limit$) {
        dataRaw = dataRaw.slice(0, where.limit$)
        data = data.slice(0, where.limit$)
      }

      if (where.sort$) {
        data.sort(_sort(where.sort$))
      }
      resolve({dataRaw, data})
    })
  })
}

function _sort (condition) {
  return (a, b) => {
    let order = 0

    const keys = Object.keys(condition)

    for (let k of keys) {
      if (typeof a[k] === 'string') {
        order = a[k].localeCompare(b[k]) * condition[k]
      } else {
        order = a[k] * condition[k] - b[k] * condition[k]
      }

      if (order !== 0) break
    }

    return order
  }
}
/**
 *
 * @param dataRaw
 * @param bundle
 * @param fields
 * @returns {Promise}
 */
export function updatePromisified (dataRaw, bundle, fields) {
  return new Promise((resolve, reject) => {
    const originalDoc = dataRaw.data$()

    const updatedDoc = lodash.reduce(fields, (acc, f) => {
      const fieldToUpdate = lodashFp.set(f, lodash.get(bundle, f), acc)

      const merged = lodash.mergeWith(originalDoc, fieldToUpdate, (origValue, newValue) => {
        if (f.indexOf('.') > 0) {
          return Object.assign({}, origValue, newValue)
        }

        if (lodash.isArray(origValue) || lodash.isPlainObject(origValue)) {
          return newValue
        }
      })

      return merged
    }, {})

    dataRaw.data$(updatedDoc)
           .save$((err, dataRaw) => {
             if (err) return reject(err)

             const data = dataRaw.data$()
             resolve({dataRaw, data})
           })
  })
}
/**
 *
 * @param where
 * @param opFields
 * @param collection
 * @returns {Promise}
 */
export function updateNativePromisified (where, opFields, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.native$((err, db) => {
      if (err) return reject(err)

      db.collection(collection)
        .findAndModify(where, [['_id', 'asc']], opFields, {new: true}, (err, result) => {
          if (err) return reject(err)
          resolve(result.value)
        })
    })
  })
}
/**
 *
 * @param {Object} where - Query to be executed
 * @param {String} collection - Collection to be used
 * @returns {Promise} { dataRaw, data }
 */
export function removeNativePromisified (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.native$((err, db) => {
      if (err) return reject(err)

      db.collection(collection)
        .remove(where, (err, result) => {
          if (err) return reject(err)
          resolve(result.result)
        })
    })
  })
}
/**
 *
 * @param {Object} where - Query to be executed
 * @param {String} collection - Collection to be used
 * @returns {Promise} { dataRaw, data }
 */
export function removePromisified (where, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    query.remove$(where, (err, data) => {
      if (err) return reject(err)
      if (!data) return reject(err)

      // It can only remove when value at a time.
      // So if it wasn't errors it means it deleted one element.
      resolve(1)
    })
  })
}
/**
 *
 * @param object
 * @param keyString
 * @param select
 * @param collection
 * @returns {Promise}
 */
export function populatePromisified (object, keyString, select, collection) {
  let seneca = this

  return new Promise((resolve, reject) => {
    let query = seneca.make$(collection)

    // Lodash 'at' function always returns an array.
    // That's why head is invoked, it gets the first
    // element of the array, in fact, the only one.
    const subtree = lodash.chain(object)
                          .at(keyString)
                          .head()
                          .value()

    async.map(subtree, (id, next) => {
      return _load(id, query, next)
    }, (err, values) => {
      if (err) return reject(err)
      const validValues = values.filter((v) => v !== undefined)

      let toMerge = validValues

      if (select.length > 0) {
        toMerge = lodash.reduce(validValues, (result, v) => {
          let elements = lodash.reduce(select, (acc, s) => {
            let {fieldKey, fieldValue} = _getFieldValue(v, s)
            return lodashFp.set(fieldKey, fieldValue, acc)
          }, {})

          return result.concat(elements)
        }, [])
      }

      resolve(lodashFp.set(keyString, toMerge, object))
    }
    )
  })
}
/**
 *
 * @returns {string} - Generate a mongoObjectId
 */
export function mongoObjectId () {
  var timestamp = (new Date().getTime() / 1000 | 0).toString(16)
  return timestamp + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, () => (Math.random() * 16 | 0).toString(16))
                                       .toLowerCase()
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-db.html">db</a></li><li><a href="module-debug.html">debug</a></li><li><a href="module-handler.html">handler</a></li><li><a href="module-microservice.html">microservice</a></li><li><a href="module-validate.html">validate</a></li></ul><h3>Classes</h3><ul><li><a href="module-microservice-$pipePromise.html">$pipePromise</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Apr 24 2017 15:32:18 GMT-0300 (-03)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
