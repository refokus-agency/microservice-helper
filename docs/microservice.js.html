<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: microservice.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: microservice.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 *  Microservices pipeline.
 * @module
 */

// NOTE: we need to remove no-labels for this project, try to avoid this kind of fixes
/* eslint-disable no-labels */

import {printModule} from './debug'

/** Class representing a custom Promise. */
class $pipePromise {
  /**
   * Basic Promise object that is transported across de pipeline
   * @param {Function} fnc - Function to execute in the pipeline
   * @param {Object} state - Current state of the App
   * @param {boolean} [critical] - When $critical is present, an exception stop de pipe execution
   */
  constructor (fnc, state, critical) {
    this.state = state
    this.promise = new Promise((resolve, reject) => {
      try {
        const fncCalled = fnc(this.state)

        if (!(fncCalled instanceof Promise)) {
          return this._successHandler(fncCalled, resolve)
        }

        return fncCalled.then(fncState => {
          return this._successHandler(fncState, resolve)
        })
        .catch(error => {
          return this._errorHandler(error, critical, reject, resolve)
        })
      } catch (error) {
        return this._errorHandler(error, critical, reject, resolve)
      }
    })
  }

  _successHandler (nState, resolve) {
    this.state = Object.assign({}, this.state, nState)
    return resolve(this.state)
  }

  _errorHandler (error, critical, reject, resolve) {
    if (critical || this.critical) {
      this.critical = true
      return reject(error)
    }
    console.warn(error)
    this.state = Object.assign({}, this.state, {error})
    return resolve(this.state)
  }

  then (fnc, critical) {
    this.promise = this.promise.then(fnc)
        .then(nState => {
          this.state = Object.assign({}, this.state, nState)

          return this.state
        })
        .catch(error => {
          if (critical || this.critical) {
            this.critical = true
            throw error
          }
          console.warn(error)
          this.state = Object.assign({}, this.state, {error})
          return this.state
        })

    return this
  }

  debug (scope = 'default') {
    return this.then(printModule(scope))
  }
}
/**
 *
 * @param {Function} fnc - Function to execute in the pipeline
 * @param {Object} state - Current state of the App
 * @param {boolean} [critical] - When $critical is present, an exception stop de pipe execution
 * @returns {$pipePromise}
 */
function $pipe (fnc, state, critical) {
  return new $pipePromise(fnc, state, critical)
}

function _generateState (seneca, msg) {
  const notAllowedKeys = ['caller$', 'meta$', 'plugin$', 'tx$']
  let nMsg = {}

  for (let key in msg) {
    if (notAllowedKeys.indexOf(key) > -1) continue
    nMsg[key] = msg[key]
  }

  return Object.assign({}, {seneca}, nMsg)
}
/**
 * Wrapper function. If all is ok, the result will be { ok : true , data : {result} } /n
 * When is an error in business logic, the result will be { ok : false, err : Error } and, /n
 * @param {Function} fnc - Command function that must be executed
 * @returns {Object}
 */
export function doFn (fnc) {
  return function (msg, done) {
    const state = _generateState(this, msg)

    let returnData = {}

    tryFnc:
      try {
        const finalState = fnc($pipe, true, state)

        if (!(finalState instanceof $pipePromise)) {
          returnData = {ok: true, data: finalState}
          break tryFnc
        }

        finalState.promise.then(finalState => {
          done(null, {ok: true, data: finalState})
        })
                  .catch(err => {
                    console.error(err)
                    done(null, {ok: false, error: err})
                  })
        return
      } catch (err) {
        returnData = {ok: false, error: err}
      }

    done(null, returnData)
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-db.html">db</a></li><li><a href="module-debug.html">debug</a></li><li><a href="module-handler.html">handler</a></li><li><a href="module-microservice.html">microservice</a></li><li><a href="module-validate.html">validate</a></li></ul><h3>Classes</h3><ul><li><a href="module-microservice-$pipePromise.html">$pipePromise</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Apr 24 2017 12:04:47 GMT-0300 (-03)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
